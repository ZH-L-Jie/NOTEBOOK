# Redis随堂笔记

## 1、整合springboot：

- springboot	2.x以下用的是Jedis
- springboot     以上用的是 lettuce
- 配置yml的redis文件时：根据AutoConfig查找配置的属性值，以前的版本和新版本有些许不同
- Template：方便我们操作redis数据库，我们在此基础上再封装Util工具类
- Redis工具类：包含自主抛出异常，简化原生的操作，网上有一大堆的代码观看（务必要仔细研究原理）

## 2、远程操作Redis

- 听说注释bind就可以了
- 关于关闭保护模式还有待商议

## 3、缓存穿透、缓存击穿、缓存雪崩

- **==缓存穿透==**：缓存查询一个一定不存在的数据，从存储层查不到数据则不写入缓存 ，每一次的查询都会直接去DB查询，如果恶意查询会导致DB崩掉

  -  布隆过滤器 ：对所有可能查询的参数以hash形式存储，在控制层先进行校验。
  - DB直接返回一个Null值，进入缓存，过期时间会很短。

- **==缓存雪崩==**： 设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩 。（多个数据几天过期）

  ​			类型2：缓存服务器某个节点宕机或断网，新建的缓存也会对DB造成一定的压力

  ​			类型3：缓存服务器直接宕机，全部的访问压力就会放在DB上，不堪重负

  - **redis 高可用** 多设几台redis（哨兵模式）类型2 解决

  - **限流降级** 加锁或者队列的方式保证缓存的单线 程（进程）写 
  - **数据预热**简单方案： 在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低 

- **==缓存击穿==**： 对于一些设置了过期时间的key，如果这些key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据 

  - **设置热点数据永不过期** 

    从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。 

    **加互斥锁** 

    分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布 式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考 

    验很大。 

    
    
    
    ![1595599730391](Redis%E9%9A%8F%E5%A0%82%E7%AC%94%E8%AE%B0.assets/1595599730391.png)